<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>SharePreferences原理浅析 | Hopkin</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SharePreferences原理浅析</h1><a id="logo" href="/.">Hopkin</a><p class="description">一个普通程序员的碎碎念 (。・∀・)ノ</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">SharePreferences原理浅析</h1><div class="post-meta">Mar 22, 2020<span> | </span><span class="category"><a href="/categories/计算机基础/">计算机基础</a><a href="/categories/计算机基础/Android基础/">Android基础</a></span></div><div class="post-content"><h1 id="SharePreferences原理浅析"><a href="#SharePreferences原理浅析" class="headerlink" title="SharePreferences原理浅析"></a>SharePreferences原理浅析</h1><p><em>作为Android基本的存储方式，一直以来对于SharePreferences都是一知半解的情况，仅停留在使用层面，未曾看过源码实现，所以有时候遇到问题也是有点困惑，今天大致看了下其实现，故总结一下以做记录</em></p>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>我们知道，SharePreferences是以xml文件的形式组织key-value存在的，那具体是如何读取的呢？首先找到<code>Context.getSharedPreferences() -&gt; ContextImpl.getSharedPreferences()</code>查看信息。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> SharedPreferences getSharedPreferences(String name, <span class="keyword">int</span> mode) &#123;</span><br><span class="line">    <span class="comment">// At least one application in the world actually passes in a null</span></span><br><span class="line">    <span class="comment">// name.  This happened to work because when we generated the file name</span></span><br><span class="line">    <span class="comment">// we would stringify it to "null.xml".  Nice.</span></span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">            Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            name = <span class="string">"null"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">File</span> <span class="keyword">file</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (ContextImpl.<span class="keyword">class</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mSharedPrefsPaths == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 </span><br><span class="line">            <span class="comment">//先new 了一个 ArrayMap&lt;String, File&gt;，存放name对应的xml文件对象 </span></span><br><span class="line">            mSharedPrefsPaths = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">file</span> = mSharedPrefsPaths.get(name);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">file</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">file</span> = getSharedPreferencesPath(name);</span><br><span class="line">            mSharedPrefsPaths.put(name, <span class="keyword">file</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再进入这个函数</span></span><br><span class="line">    <span class="keyword">return</span> getSharedPreferences(<span class="keyword">file</span>, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> SharedPreferences getSharedPreferences(<span class="keyword">File</span> <span class="keyword">file</span>, <span class="keyword">int</span> mode) &#123;</span><br><span class="line">    checkMode(mode);</span><br><span class="line">    <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">        ......<span class="comment">//省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    <span class="keyword">synchronized</span> (ContextImpl.<span class="keyword">class</span>) &#123;</span><br><span class="line">        <span class="comment">//这里又new了一个缓存map，这个map比较重要，存储的是每一个xml文件在内存中一一应的SharedPreferencesImpl实例，这个实例有个map对象就是存放这个文件真正的内容</span></span><br><span class="line">        <span class="keyword">final</span> ArrayMap&lt;<span class="keyword">File</span>, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();</span><br><span class="line">        sp = cache.get(<span class="keyword">file</span>);</span><br><span class="line">        <span class="keyword">if</span> (sp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sp = <span class="keyword">new</span> SharedPreferencesImpl(<span class="keyword">file</span>, mode);</span><br><span class="line">            <span class="comment">//放入缓存，返回创建的对象</span></span><br><span class="line">            cache.put(<span class="keyword">file</span>, sp);</span><br><span class="line">            <span class="keyword">return</span> sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((mode &amp; Context.MODE_MULTI_PROCESS) != <span class="number">0</span> ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        ...<span class="comment">//省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上的代码可以看出，每个xml文件最终会一一对应在内存中缓存的SharedPreferencesImpl实例，该对象有个成员变量<code>private Map&lt;String, Object&gt; mMap</code>，就是读取出来后转换存放的key-value，可以看以下代码：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">SharedPreferencesImpl(File file, <span class="built_in">int</span> mode) &#123;</span><br><span class="line">    mFile = file;</span><br><span class="line">    <span class="comment">//其实就是准备把xml文件备份，先创建File对象</span></span><br><span class="line">    mBackupFile = makeBackupFile(file);</span><br><span class="line">    mMode = mode;</span><br><span class="line">    mLoaded = <span class="keyword">false</span>;</span><br><span class="line">    mMap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//第一次使用开始加载</span></span><br><span class="line">    startLoadFromDisk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> File makeBackupFile(File prefsFile) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> File(prefsFile.getPath() + <span class="string">".bak"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> startLoadFromDisk() &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mLoaded = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取文件使用了子线程</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"SharedPreferencesImpl-load"</span>) &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">            loadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> loadFromDisk() &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLoaded) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可以先忽略这里，一开始肯定不存在的</span></span><br><span class="line">        <span class="keyword">if</span> (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debugging</span></span><br><span class="line">    <span class="keyword">if</span> (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Attempt to read preferences file "</span> + mFile + <span class="string">" without permission"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map <span class="built_in">map</span> = <span class="keyword">null</span>;</span><br><span class="line">    StructStat stat = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stat = Os.stat(mFile.getPath());</span><br><span class="line">        <span class="keyword">if</span> (mFile.canRead()) &#123;</span><br><span class="line">            BufferedInputStream <span class="built_in">str</span> = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">str</span> = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(mFile), <span class="number">16</span>*<span class="number">1024</span>);</span><br><span class="line">                <span class="comment">//读取到了map</span></span><br><span class="line">                <span class="built_in">map</span> = XmlUtils.readMapXml(<span class="built_in">str</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Cannot read "</span> + mFile.getAbsolutePath(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                IoUtils.closeQuietly(<span class="built_in">str</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line">        <span class="comment">/* ignore */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mLoaded = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMap = <span class="built_in">map</span>;</span><br><span class="line">            mStatTimestamp = stat.st_mtime;</span><br><span class="line">            mStatSize = stat.st_size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMap = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//唤醒等待的线程，因为之前别人get 或put的时候还没加载完可能阻塞了</span></span><br><span class="line">        mLock.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>已经了解了文件的读取加载过程，接下来我们来看如何使用getXXX去获取值</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> getString(<span class="keyword">String</span> <span class="built_in">key</span>, @Nullable <span class="keyword">String</span> defValue) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();<span class="comment">//这个地方遇到正在加载文件时候会阻塞，是在当前线程</span></span><br><span class="line">        <span class="keyword">String</span> v = (<span class="keyword">String</span>)mMap.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">        <span class="keyword">return</span> v != <span class="keyword">null</span> ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> awaitLoadedLocked() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="comment">// Raise an explicit StrictMode onReadFromDisk for this</span></span><br><span class="line">        <span class="comment">// thread, since the real read will be in a different</span></span><br><span class="line">        <span class="comment">// thread and otherwise ignored by StrictMode.</span></span><br><span class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上可知，get比较简单，直接从缓存的SharedPreferencesImpl实例的map对象中去取，如果文件还在加载，就阻塞直到加载完毕。</p>
<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>写入首先要用到<code>edit()</code>，然后再使用<code>putXXX()</code>，我们来看下这两个</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> Editor edit() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> remove the need to call awaitLoadedLocked() when</span></span><br><span class="line">    <span class="comment">// requesting an editor.  will require some work on the</span></span><br><span class="line">    <span class="comment">// Editor, but then we should be able to do:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//      context.getSharedPreferences(..).edit().putString(..).apply()</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// ... all without blocking.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();/阻塞</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EditorImpl();<span class="comment">//返回EidtorImpl实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//这个是EditorImpl的成员变量，也就是putXXX临时会放入的map，最后提交时才会写入SharedPreferencesImpl的map，我们一会再看</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; mModified = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//putXXX也没有什么好说的了</span></span><br><span class="line">    <span class="keyword">public</span> Editor putString(<span class="keyword">String</span> <span class="built_in">key</span>, @Nullable <span class="keyword">String</span> value) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            mModified.put(<span class="built_in">key</span>, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其实比较关键的就是写入，因为不仅仅是putXXX就完事了，这里面需要用到<code>apply()</code>或者<code>commit()</code>，也需要重点区分他们的区别，一个是同步的，一个是异步的，怎么说？</p>
<h4 id="commit"><a href="#commit" class="headerlink" title="commit()"></a>commit()</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> commit() &#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            startTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MemoryCommitResult mcr = commitToMemory();<span class="comment">//这个其实就是将mModified同步回主存的map</span></span><br><span class="line">        <span class="comment">//直接写入外存</span></span><br><span class="line">        SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(</span><br><span class="line">            mcr, <span class="keyword">null</span> <span class="comment">/* sync write on this thread okay */</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mcr.writtenToDiskLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, mFile.getName() + <span class="string">":"</span> + mcr.memoryStateGeneration</span><br><span class="line">                        + <span class="string">" committed after "</span> + (System.currentTimeMillis() - startTime)</span><br><span class="line">                        + <span class="string">" ms"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        notifyListeners(mcr);</span><br><span class="line">        <span class="keyword">return</span> mcr.writeToDiskResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MemoryCommitResult commitToMemory() &#123;</span><br><span class="line">        ...<span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; e : mModified.entrySet()) &#123;</span><br><span class="line">                    <span class="keyword">String</span> k = e.getKey();</span><br><span class="line">                    <span class="keyword">Object</span> v = e.getValue();</span><br><span class="line">                    <span class="comment">// "this" is the magic value for a removal mutation. In addition,</span></span><br><span class="line">                    <span class="comment">// setting a value to "null" for a given key is specified to be</span></span><br><span class="line">                    <span class="comment">// equivalent to calling remove on that key.</span></span><br><span class="line">                    <span class="keyword">if</span> (v == <span class="keyword">this</span> || v == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!mMap.containsKey(k)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mMap.remove(k);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mMap.containsKey(k)) &#123;</span><br><span class="line">                            <span class="keyword">Object</span> existingValue = mMap.<span class="built_in">get</span>(k);</span><br><span class="line">                            <span class="keyword">if</span> (existingValue != <span class="keyword">null</span> &amp;&amp; existingValue.equals(v)) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mMap.put(k, v);<span class="comment">//写入</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    changesMade = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (hasListeners) &#123;</span><br><span class="line">                        keysModified.<span class="built_in">add</span>(k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mModified.<span class="built_in">clear</span>();<span class="comment">//提交后清空临时map</span></span><br><span class="line">            ...<span class="comment">//省略</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MemoryCommitResult(memoryStateGeneration, keysModified, listeners,</span><br><span class="line">                mapToWriteToDisk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enqueue an already-committed-to-memory result to be written</span></span><br><span class="line"><span class="comment"> * to disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * They will be written to disk one-at-a-time in the order</span></span><br><span class="line"><span class="comment"> * that they're enqueued.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param postWriteRunnable if non-null, we're being called</span></span><br><span class="line"><span class="comment"> *   from apply() and this is the runnable to run after</span></span><br><span class="line"><span class="comment"> *   the write proceeds.  if null (from a regular commit()),</span></span><br><span class="line"><span class="comment"> *   then we're allowed to do this disk write on the main</span></span><br><span class="line"><span class="comment"> *   thread (which in addition to reducing allocations and</span></span><br><span class="line"><span class="comment"> *   creating a background thread, this has the advantage that</span></span><br><span class="line"><span class="comment"> *   we catch them in userdebug StrictMode reports to convert</span></span><br><span class="line"><span class="comment"> *   them where possible to apply() ...)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> enqueueDiskWrite(<span class="keyword">final</span> MemoryCommitResult mcr,</span><br><span class="line">                              <span class="keyword">final</span> Runnable postWriteRunnable) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">boolean</span> isFromSyncCommit = (postWriteRunnable == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Runnable writeToDiskRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mWritingToDiskLock) &#123;</span><br><span class="line">                    <span class="comment">//写入外存，这个函数会将当前的文件重命名为备份文件，map写入为一个新文件，成功后删除备份，失败回滚，就不跟进去了</span></span><br><span class="line">                    writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    mDiskWritesInFlight--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (postWriteRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    postWriteRunnable.run();<span class="comment">//这个可以不必太关心</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Typical #commit() path with fewer allocations, doing a write on</span></span><br><span class="line">    <span class="comment">// the current thread.</span></span><br><span class="line">    <span class="comment">//如果是commit，就是同步的，那么进入if里面</span></span><br><span class="line">    <span class="keyword">if</span> (isFromSyncCommit) &#123; </span><br><span class="line">        <span class="built_in">boolean</span> wasEmpty = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            wasEmpty = mDiskWritesInFlight == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wasEmpty) &#123;</span><br><span class="line">            writeToDiskRunnable.run();<span class="comment">//执行写入任务</span></span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里会进入子线程执行，当然apply()调用的会走到这里，区别就看出来了，他是用子线程写入的，其实是一个HandlerThread。。。</span></span><br><span class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p><code>commit()</code>已经了解了，就是调用后直接在当前线程吧存入的临时map数据写入主存的map，然后在当前线程直接执行写入外存的任务，确实是当前线程，所以性能不是很好，因为我们一般会在主线程使用sharePreferences。好了，再看下<code>apply()</code>的区别</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();<span class="comment">//前面分析过了，就是写入主存的map</span></span><br><span class="line">        <span class="keyword">final</span> Runnable awaitCommit = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        mcr.writtenToDiskLatch.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (DEBUG &amp;&amp; mcr.wasWritten) &#123;</span><br><span class="line">                        Log.d(TAG, mFile.getName() + <span class="string">":"</span> + mcr.memoryStateGeneration</span><br><span class="line">                                + <span class="string">" applied after "</span> + (System.currentTimeMillis() - startTime)</span><br><span class="line">                                + <span class="string">" ms"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">        Runnable postWriteRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    awaitCommit.run();</span><br><span class="line">                    QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="comment">//重点在这里，跟进这个函数，上面分析过了，会由HandlerThread执行</span></span><br><span class="line">        SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Okay to notify the listeners before it's hit disk</span></span><br><span class="line">        <span class="comment">// because the listeners should always get the same</span></span><br><span class="line">        <span class="comment">// SharedPreferences instance back, which has the</span></span><br><span class="line">        <span class="comment">// changes reflected in memory.</span></span><br><span class="line">        notifyListeners(mcr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以可以看到<code>aply() commit()</code>的核心区别在于前者是put后同步主存后在子线程写入新文件，后者是直接在当前线程写入文件</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>每一个xml文件是整个加载入内存的，对应一个SharedPreferencesImpl对象和一个map，所以不适合存储大量数据，因为首次加载读取会非常耗时，虽然是子线程加载，但是使用<code>edit()</code>会阻塞到加载完成，有aar和oom等性能问题</li>
<li>优先使用apply，因为commit是在当前线程直接写入，如果经常提交修改，容易给当前线程(一般是UI线程操作)带来负担；apply是在子线程写入，所以说是异步的，性能也会更好，后续的提交可能会使子线程在写入时数据被更新，但一般是没有问题的，因为最新的提交后续还会再写入一遍</li>
<li>由源码可以知道，sharePreferences是不合适多线程使用的，因为依然存在数据同步性问题，多线程同时操作主存的arrayMap依然是不稳定的，最好避免多线程和多进程使用</li>
</ul>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>hopkin</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/03/22/SharePreferences原理浅析/">https://hb-pencil.github.io/2020/03/22/SharePreferences原理浅析/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>Copyright © 2019 Hopkin</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://hb-pencil.github.io/2020/03/22/SharePreferences原理浅析/" data-id="ck82x5r9i0052rgibyfzfk8le" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACuElEQVR42u3aQW7jQAwEwPz/0w6w10TablIT+1A6GQIiTynAcNzk11d8vf5dP+/8vH/1V1dPSD4n37W68PDw8EZLv7ryxeXLSu4kL+t+zXh4eHinebNt/X7L3vPy1315Hw8PD++tvASZlIT8yfnrxsPDw/tMXh4c5OXhftNPPuPh4eG9i5eEEUkc0IYFSRC8eT4eHh7eCV7bAPuEzwf7e3h4eHiLrnrbGMubWG34O1whHh4e3gFePj6Vj1vVX39LyscUhsvFw8PDW/Py8alNLJu3u/atMjw8PLxzvH0AkQQZmwN0Pp51pL+Hh4eHVx6R8615tvVvSA/8AsDDw8Nb8zZxQ1tg2hgizxnw8PDwTvBmA095Kytf4lPrGZ7l8fDw8GLeJlBol9WWljp0mGUheHh4eCNeEiLso4R20KptreHh4eH9Da/92Z8XlfZl5c2wAoyHh4d3gHfi4PuKr02hqgNoPDw8vId4s2LQHnZnY1Wz1lpU9/Dw8PC2E1NFXJsvrt3i87B4Fe/i4eHhrXntVp5v3G1TrS0DUYnCw8PDO8bLxwLy1zE7srfNtv+sBA8PD+8YL29EzeKAWQnZlJa6O4eHh4dX8vJRp2dDh9m3F2w8PDy8P+HNDrX5xj3c4keBCB4eHt4JXj4m1XbSThyj81VdHqzx8PDwHuIlV1sGNmMHm4Gt4YWHh4dX8pKW0gaWI/f/k+J3Ax4eHt4x3v2BdYPfjFjh4eHhvYv3Kq+2GLQDW/mBu54pw8PDw3uItw8j2vGCfNRg84Iey1rw8PDwggGCdsSqXW77gnL2cHQADw8Pb8G7v58sehYE18stRwrw8PDwPoeXxBB5sdmUkyilxsPDw3sTbz8EsImMh20zPDw8vGO8WfNpcxDfxBlFGo2Hh4d3gDdrgOXN+xmjjZIf7u/h4eHh/f7Mb/v1nHEiXSpyAAAAAElFTkSuQmCC">分享</a><div class="tags"></div><div class="post-nav"><a class="next" href="/2020/01/12/Binder IPC/">Binder &amp; TCP</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/Android基础/">Android基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/Android知识/">Android知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/计算机网络/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/计算机语言/">计算机语言</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/经验记录/" style="font-size: 15px;">经验记录</a> <a href="/tags/随笔杂文/" style="font-size: 15px;">随笔杂文</a> <a href="/tags/小技巧/" style="font-size: 15px;">小技巧</a> <a href="/tags/计算机知识/" style="font-size: 15px;">计算机知识</a> <a href="/tags/零碎知识/" style="font-size: 15px;">零碎知识</a> <a href="/tags/他山之石/" style="font-size: 15px;">他山之石</a> <a href="/tags/新技术/" style="font-size: 15px;">新技术</a> <a href="/tags/胡思乱想/" style="font-size: 15px;">胡思乱想</a> <a href="/tags/经验总结/" style="font-size: 15px;">经验总结</a> <a href="/tags/kotlin/" style="font-size: 15px;">kotlin</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/22/SharePreferences原理浅析/">SharePreferences原理浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/12/Binder IPC/">Binder & TCP</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/04/经验总结(五)/">经验总结（五）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/Activity的启动过程浅析/">Activity的启动过程浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/kotlin的若干特性/">Kotln的若干特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/20/经验总结（四）/">经验总结（四）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/08/经验总结（三）/">经验总结（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/25/事件总线思想简述/">事件总线思想简述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/24/经验总结（二）/">经验总结（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/11/经验总结（一）/">经验总结（一）</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Hopkin.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>