<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Activity的启动过程浅析 | Hopkin</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Activity的启动过程浅析</h1><a id="logo" href="/.">Hopkin</a><p class="description">一个普通程序员的碎碎念 (。・∀・)ノ</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Activity的启动过程浅析</h1><div class="post-meta">Nov 23, 2019<span> | </span><span class="category"><a href="/categories/计算机基础/">计算机基础</a><a href="/categories/计算机基础/Android知识/">Android知识</a></span></div><div class="post-content"><h1 id="Activity的启动过程浅析"><a href="#Activity的启动过程浅析" class="headerlink" title="Activity的启动过程浅析"></a>Activity的启动过程浅析</h1><p>Activity的启动过程 ，也算是个老生常谈的问题了。本文尝试结合源码，通俗、简洁地了解Activity的启动的主要过程，需要注意的，阅读此文，需要有一定的知识储备。</p>
<p>先来这样一张图：<br> <img src="/2019/11/23/Activity的启动过程浅析/Activity的启动过程.jpg" alt="Activity的启动过程"></p>
<p>图中是Activity冷启动的一个简要流程</p>
<h2 id="冷启动与热启动"><a href="#冷启动与热启动" class="headerlink" title="冷启动与热启动"></a>冷启动与热启动</h2><ul>
<li>第一次点击launcher启动App即为冷启动，耗时相对较久</li>
<li>App启动后，比如在后台，这时候点击launcher启动Activity即为热启动，速度快</li>
</ul>
<p><strong>先说结论：</strong></p>
<p>整体流程是这样的，当用户点击图标icon时，系统会调用<code>Launher.startActivity() -&gt; AMS.startActivity()</code>，这时候AMS会判断进程是否已经启动，如果已经启动，AMS就通过binder通信调用到主线程的H(UI线程的hander)发送启动消息，然后主线程消息循环直接处理；如果未启动，则如上图，AMS会调用<code>Process.start()</code>通过系统进程启动进程，这个系统进程通过socket与Zygote进程进行IPC，该socket为localSocket，然后Zygote进程fork出一个一模一样的进程，在进程里面调用<code>ActivityThread.main()</code>完成启动，然后继续走到我们熟悉的消息循环。</p>
<p>本文不关心Zygote进程启动的相关细节，重点放在ActivityThread.main()的启动流程，因为冷启动的入口正是这里，这里搞明白了，热启动自然就清楚了。</p>
<p>ActivityThread是一个类，和线程没什么关系。先来看下入口main函数。需要关注的已经添加了注释了，其他的不必太关心，不影响我们对主流程的理解。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化主线程的Looper,这是第一个重点关注的地方，源码在后面，这块是消息机制，熟悉可跳过</span></span><br><span class="line">    Looper.prepareMainLooper(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个是重点，第二个关注的地方，待会会进行分析</span></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread(); </span><br><span class="line">    <span class="comment">//这个是第三个需要重点关注的地方</span></span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123; </span><br><span class="line">    <span class="comment">//这个也是主线程的handler，不过不是H handler,暂时不用关注 </span></span><br><span class="line">        sMainThreadHandler = thread.getHandler(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启消息循环等待消息</span></span><br><span class="line">    Looper.<span class="built_in">loop</span>();</span><br></pre></td></tr></table></figure>
<p>接下来看下<code>Looper.prepareMainLooper();</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment"> * application's main looper. The main looper for your application</span></span><br><span class="line"><span class="comment"> * is created by the Android environment, so you should never need</span></span><br><span class="line"><span class="comment"> * to call this function yourself.  See also: &#123;@link #prepare()&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//此处是初始化looper</span></span><br><span class="line">    prepare(<span class="literal">false</span>);  </span><br><span class="line">    synchronized (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();<span class="comment">//此处是获取已经初始化的looper</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个地方设计到ThreadLocal的知识，这里也不展开讲了，ThreadLocal在Java和Android中的实现</span></span><br><span class="line"><span class="comment"> * 略有差异，不过基本是一致的，可以去自行了解一下</span></span><br><span class="line"><span class="comment"> * 简言之，threadLocal允许我们在不同的线程使用同一个key(threadLocal)储存线程独立的数据，在</span></span><br><span class="line"><span class="comment"> * 不同的线程中都可以通过同一个key取出各自线程独立的数据，Android用来储存looper</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span>(<span class="params">boolean quitAllowed</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.<span class="keyword">get</span>() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例化主线程的looper，我们知道每个线程都有一个唯一的looper，looper中持有一个唯一的消息</span></span><br><span class="line">    <span class="comment">//队列messageQueue(消息队列是一个linkList数据结构)，消息循环通过next()取出消息和处理，消息循环的知识也不多讲了，就到此为止</span></span><br><span class="line">    sThreadLocal.<span class="keyword">set</span>(<span class="keyword">new</span> Looper(quitAllowed)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是需要重点关注的<code>ActivityThread thread = new ActivityThread();</code></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//部分重要成员变量：</span></span><br><span class="line"><span class="keyword">final</span> ApplicationThread mAppThread = <span class="keyword">new</span> ApplicationThread();</span><br><span class="line"><span class="keyword">final</span> Looper mLooper = Looper.myLooper();</span><br><span class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</span><br></pre></td></tr></table></figure>
<p>可以看到当实例化ActivityThread时，以上几个成员变量也会被初始化，先看下ApplicationThread</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> class ApplicationThread extends IApplicationThread.Stub &#123;</span><br><span class="line">    <span class="keyword">private</span> static final <span class="built_in">String</span> DB_INFO_FORMAT = <span class="string">"  %8s %8s %14s %14s  %s"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> int mLastProcessState = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="params">...</span></span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> final <span class="literal">void</span> scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">            ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">            CompatibilityInfo compatInfo, <span class="built_in">String</span> <span class="keyword">referrer</span>, IVoiceInteractor voiceInteractor,</span><br><span class="line">            int procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">            <span class="built_in">List</span>&lt;ResultInfo&gt; pendingResults, <span class="built_in">List</span>&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">            <span class="built_in">boolean</span> notResumed, <span class="built_in">boolean</span> isForward, ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">        updateProcessState(procState, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        ActivityClientRecord r = <span class="literal">new</span> ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">        <span class="params">...</span><span class="params">...</span></span><br><span class="line"></span><br><span class="line">        sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="params">...</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里先忽略，下面会提及</span></span><br><span class="line">    <span class="keyword">public</span> final <span class="literal">void</span> bindApplication(<span class="built_in">String</span> processName, ApplicationInfo appInfo,</span><br><span class="line">            <span class="built_in">List</span>&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">            ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">            IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">            IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">            <span class="built_in">boolean</span> enableBinderTracking, <span class="built_in">boolean</span> trackAllocation,</span><br><span class="line">            <span class="built_in">boolean</span> isRestrictedBackupMode, <span class="built_in">boolean</span> persistent, Configuration config,</span><br><span class="line">            CompatibilityInfo compatInfo, <span class="built_in">Map</span> services, Bundle coreSettings,</span><br><span class="line">            <span class="built_in">String</span> buildSerial) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (services != <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Setup the service cache in the ServiceManager</span></span><br><span class="line">            ServiceManager.initServiceCache(services);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setCoreSettings(coreSettings);</span><br><span class="line"></span><br><span class="line">        AppBindData <span class="built_in">data</span> = <span class="literal">new</span> AppBindData();</span><br><span class="line">        <span class="built_in">data</span>.processName = processName;</span><br><span class="line">        <span class="built_in">data</span>.appInfo = appInfo;</span><br><span class="line"></span><br><span class="line">        <span class="params">...</span><span class="params">...</span></span><br><span class="line"></span><br><span class="line">        sendMessage(H.BIND_APPLICATION, <span class="built_in">data</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到IApplicationThread是一个AIDL接口，ApplicationThread是一个实现类，接口定义了一系列操作，包括Activity、BrocastReceiver、Service生命周期的各种操作等等，接下来看看<code>thread.attach(false)</code> 这个方法。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">      sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">      mSystemThread = system;</span><br><span class="line">      <span class="keyword">if</span> (!system) &#123;</span><br><span class="line"></span><br><span class="line">          ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里是把我们的ApplicationThread AIDL实例付给了AMS,事实上，AMS里也有一个用于IPC</span></span><br><span class="line">        <span class="comment">//的Binder IActivityManager，通过getService()获IActivityManager.Stub.asInterfac(b)</span></span><br><span class="line">        <span class="comment">//类似于我们编写AIDL时客户端获得的Binder的代理，通过binder代理把我们的</span></span><br><span class="line">        <span class="comment">//ApplicationThread这个binder传给了AMS,以后AMS就靠这个获取的binder与进行我们程序通信</span></span><br><span class="line">       </span><br><span class="line">          RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">          <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              mgr.attachApplication(mAppThread);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">              <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">         ......</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Don't set application object here -- if the system crashes,</span></span><br><span class="line">          <span class="comment">// we can't display an alert, we just want to die die die.</span></span><br><span class="line">          android.ddm.DdmHandleAppName.setAppName(<span class="string">"system_process"</span>,</span><br><span class="line">                  UserHandle.myUserId());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">              ContextImpl context = ContextImpl.createAppContext(</span><br><span class="line">                      <span class="keyword">this</span>, getSystemContext().mPackageInfo);</span><br><span class="line">              mInitialApplication = context.mPackageInfo.makeApplication(<span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">              mInitialApplication.onCreate();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                      <span class="string">"Unable to instantiate Application():"</span> + e.toString(), e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//----------------begin:注意这里是AMS里面的------------------</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">IActivityManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">return</span> IActivityManagerSingleton.<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">          <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">protected</span> <span class="function">IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                  <span class="keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                  <span class="keyword">return</span> am;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">  <span class="comment">//----------------end:注意这里是AMS里面的------------------</span></span><br></pre></td></tr></table></figure>
<p>我们可以猜想，当AMS拿到我们的binder之后，第一件事是做什么呢？当然发消息啦，并且应该是初始化Application的消息，可以继续往上看刚才说忽略的<code>bindApplication()</code>，这里应该是AMS通过binder调用的，这个方法也是通过H发送了一个消息H.BIND_APPLICATION，并传入一系列初始信息，当然AMS从Zygote fork进程之后也有一些相应的初始信息，总之将AMS先把我们的App初始化，接着看哪里处理消息</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="literal">void</span> handleBindApplication(AppBindData <span class="built_in">data</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="params">...</span><span class="params">...</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//这里实例化App,会调用到attachToBaseContext()</span></span><br><span class="line"></span><br><span class="line">       Application app = <span class="built_in">data</span>.info.makeApplication(<span class="built_in">data</span>.restrictedBackupMode, <span class="built_in">null</span>);</span><br><span class="line">       mInitialApplication = app;</span><br><span class="line">      </span><br><span class="line">      <span class="params">...</span><span class="params">...</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">data</span>.restrictedBackupMode) &#123;</span><br><span class="line">              <span class="keyword">if</span> (!ArrayUtils.isEmpty(<span class="built_in">data</span>.providers)) &#123;</span><br><span class="line">                  </span><br><span class="line">                  <span class="comment">//注意这里，是初始化 所有 的Providers</span></span><br><span class="line">                  installContentProviders(app, <span class="built_in">data</span>.providers);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// For process that contains content providers, we want to</span></span><br><span class="line">                  <span class="comment">// ensure that the JIT is enabled "at some point".</span></span><br><span class="line">                  mH.sendEmptyMessageDelayed(H.ENABLE_JIT, <span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Do this after providers, since instrumentation tests generally start their</span></span><br><span class="line">          <span class="comment">// test thread at this point, and we don't want that racing.</span></span><br><span class="line">          try &#123;</span><br><span class="line">            </span><br><span class="line">              <span class="comment">//事实上这里mInstrumentation才创建，也就是说callApplicationOnCreate肯定在这后调用</span></span><br><span class="line">              mInstrumentation.onCreate(<span class="built_in">data</span>.instrumentationArgs);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">       <span class="params">...</span><span class="params">...</span></span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Application的Context,Androidd的Context是装饰着模式，这里可以回顾下app context相关知识</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Application makeApplication(<span class="built_in">boolean</span> forceDefaultAppClass,</span><br><span class="line">          Instrumentation instrumentation) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mApplication != <span class="built_in">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> mApplication;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="params">...</span><span class="params">...</span></span><br><span class="line"></span><br><span class="line">      Application app = <span class="built_in">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">String</span> appClass = mApplicationInfo.className;</span><br><span class="line">      <span class="keyword">if</span> (forceDefaultAppClass || (appClass == <span class="built_in">null</span>)) &#123;</span><br><span class="line">          appClass = <span class="string">"android.app.Application"</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         </span><br><span class="line">          <span class="params">...</span><span class="params">...</span>.</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//构造的context，newApplication应该是单例，会调用到attachToBaseContext()</span></span><br><span class="line"></span><br><span class="line">          ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">          app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                  cl, appClass, appContext);</span><br><span class="line">          appContext.setOuterContext(app);</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="params">...</span><span class="params">...</span>.</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      mActivityThread.mAllApplications.add(app);</span><br><span class="line">      mApplication = app;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (instrumentation != <span class="built_in">null</span>) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">         </span><br><span class="line">              <span class="comment">//注意这里，调用了Application的onCreate()，看起来似乎时机在App </span></span><br><span class="line">              <span class="comment">//installContentProviders，事实上传入的instrumentation == null</span></span><br><span class="line"></span><br><span class="line">              instrumentation.callApplicationOnCreate(app);</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="params">...</span><span class="params">...</span></span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="params">...</span><span class="params">...</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> app;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>综上全部可见，在<code>ActivityThread</code>实例化后和attach()后，发生了很多操作。概括来说，<code>main()</code>就是先获取Looper，然后<code>new ActivityThread</code>，然后<code>ActivityThread</code>又创建了<code>ActivityThread</code>，这是一个用于IPC的binder，<code>attach()</code>通过获取AMS的binder传递我们程序的<code>binder(ActivityThread)</code>，然后后面AMS利用binder调用H发送消息，而我们主线程<code>attch()</code>之后就进入消息循环等待处理消息了；当AMS发送初始化App的消息时，最后触发了<code>handleBindApplication()</code>这样就完成了App的冷启动了。那么热启动呢？很简单，Launcher通知AMS，AMS通过binder发送启动LAUNCHER_ACTIVITY的消息即可。</p>
<h2 id="上面还有两个问题为解决："><a href="#上面还有两个问题为解决：" class="headerlink" title="上面还有两个问题为解决："></a>上面还有两个问题为解决：</h2><h3 id="Activity冷启动如何启动"><a href="#Activity冷启动如何启动" class="headerlink" title="Activity冷启动如何启动"></a>Activity冷启动如何启动</h3><p>其实我们上面说了一堆，似乎有点文不对题，明明说的Activity的启动流程啊。事实上，AMS冷启动Activity必然先初始化Application啦，AMS拿到binder之后应该是调用了启动<code>Application</code>和<code>MainActivity</code>的函数而不只是Application啦(这里未验证，没找到源码)，主线<code>looper</code>只需要依次处理消息队列重点消息即可，其他流程都是一样，无非是换成了<code>scheduleLaunchActivity() scheduleLaunchActivity()</code>而已。</p>
<h3 id="强调Application初始化几个函数的顺序是为何"><a href="#强调Application初始化几个函数的顺序是为何" class="headerlink" title="强调Application初始化几个函数的顺序是为何"></a>强调Application初始化几个函数的顺序是为何</h3><ul>
<li>attachToBaseContext()</li>
<li>installContentProviders()</li>
<li>onCreate()</li>
</ul>
<p>其实这里挺重要的，比如当我们在5.0以下遇到64K问题，使用<code>MutliDex.install()</code>，但需要优化启动速度时，就可用到。通常在<code>attachToBaseContext()</code>执行，因为如果在这之后，会导致<code>installContentProviders()</code>时候初始化Providers可能出现找不到类的异常！比如很多第三方库的Provider可能不会被打包进主dex，所以必须尽早执行<code>MutliDex.install()</code>。</p>
<p>顺便提下，通过启动优化较好的方案是，在<code>attachToBaseContext()</code>里面判断如果低于5.0,就开启启动优化，判断当前安装的apk是否修改过，如果没有，说明不是升级或者覆盖安装，不需要过来优化，直接调用<code>MutliDex.install()</code>，否则，开启子线程进行优化。因为<code>MutliDex.install()</code>大量的时间开销都消耗在了解开apk，迭代dex，把dex重新压缩为zip(事实上好像没必要压缩成zip，makeDexElements生成elements dex数组本来就支持dex和zip文件格式啊),所以如果不是首次安装的或者重装的首次打开，是没有解压和重新压缩这个耗时步骤，也就不需要额外的进程开销。至于为什么是进程而不是异步线程去优化，因为如果是线程，主线程必须等待操作完成，不然<code>ClassNotFound</code>，但是一等就可能ANR，所以用进程，而后台进程则不会。进程间的通信，则可以使用占位文件。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>hopkin</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/11/23/Activity的启动过程浅析/">https://hb-pencil.github.io/2019/11/23/Activity的启动过程浅析/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>Copyright © 2019 Hopkin</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://hb-pencil.github.io/2019/11/23/Activity的启动过程浅析/" data-id="ck4z9bw1p004us0ib777dz4y6" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACuElEQVR42u3aQZKDQAgF0Nz/0pkDpHQ+0CQunqupmGg/p6pB4PWKj/fHUT2b/3119vM7xw48PDy88dI/L3f/+dU175d+/9v7eyVrxsPDw9vm5UtMAkASMJIr54Hk8nM8PDy8B/DypdwnwUmKPAlIeHh4eM/hJWl3NTnupdR4eHh4v+UlxYjJtt4rTCTJ97FaCx4eHl7My7tIz/l7pb+Hh4eHN+6q5+MC+fZdLUm8BwceHh7eBm+eHOcDB/nST5V98fDw8DZ4k9ZXfvt54KmWQvDw8PD2eL3yax4MeuXgyb3KRQo8PDy8Ii9Jf/ObVZPv6ohVEjwu3xXw8PDwDvGqxdbqjavX6aXUhQQaDw8Pb8zLk+b8+722VjWBjkrJeHh4eGu8XsUib3RVCxxR1y4p3eLh4eEt8ObbdDVB733ea7Dh4eHh7fHK1YvWll0NCfmoQbRaPDw8vAXeJMm+37LzRDwvPeSPDw8PD2+blwMmjyBvm1VLuq/egYeHhxfz8qGBvK3VewR566swzoWHh4e3wJsXFCZlgmRx8yEGPDw8vD1eEgxyTHVYqver5O54eHh4Z3n3m3ivDVZ9WL0BrMJMGR4eHt5RXt6qTwqy1bQ7v0te8sDDw8P7Di//QW8UoNqFy1PtaLwADw8Pb4GXX6J80fHV8kCCh4eH903eZGhgkijngacafsrVCzw8PLwWb142nZRoqyGnkKbj4eHhLfNOtZ16JeByW2vencPDw8Mbw6ov/xsJepJeR2fx8PDwFni9Pbac1A6S5jxNPxYb8fDw8Fpv63nL/1T/bZ6C/9PZw8PDw1vg9RLc/Gw+KNALWodzfDw8PLyjvMkwVq+oMSoH4+Hh4T2AN698VJPjPMysxz08PDy8YjFiUmLIH2I+xhr9q/Dw8PAWeL0X/knxt7nFFx8KHh4e3gLvD/8ic6gNKA5/AAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/经验记录/">经验记录</a></div><div class="post-nav"><a class="pre" href="/2020/01/04/经验总结(五)/">经验总结（五）</a><a class="next" href="/2019/11/22/kotlin的若干特性/">Kotln的若干特性</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/Android知识/">Android知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/计算机网络/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/计算机语言/">计算机语言</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/经验记录/" style="font-size: 15px;">经验记录</a> <a href="/tags/随笔杂文/" style="font-size: 15px;">随笔杂文</a> <a href="/tags/小技巧/" style="font-size: 15px;">小技巧</a> <a href="/tags/计算机知识/" style="font-size: 15px;">计算机知识</a> <a href="/tags/他山之石/" style="font-size: 15px;">他山之石</a> <a href="/tags/新技术/" style="font-size: 15px;">新技术</a> <a href="/tags/经验总结/" style="font-size: 15px;">经验总结</a> <a href="/tags/零碎知识/" style="font-size: 15px;">零碎知识</a> <a href="/tags/胡思乱想/" style="font-size: 15px;">胡思乱想</a> <a href="/tags/kotlin/" style="font-size: 15px;">kotlin</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/04/经验总结(五)/">经验总结（五）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/Activity的启动过程浅析/">Activity的启动过程浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/kotlin的若干特性/">Kotln的若干特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/20/经验总结（四）/">经验总结（四）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/08/经验总结（三）/">经验总结（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/25/事件总线思想简述/">事件总线思想简述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/24/经验总结（二）/">经验总结（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/11/经验总结（一）/">经验总结（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/12/工作业余计划/">工作业余计划</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/08/Android自定义FlowLayout/">Android自定义FlowLayout</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Hopkin.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>