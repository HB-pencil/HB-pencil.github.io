<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>基础算法记录（二）——部分常见算法问题 | Hopkin</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">基础算法记录（二）——部分常见算法问题</h1><a id="logo" href="/.">Hopkin</a><p class="description">一个普通程序员的碎碎念 (。・∀・)ノ</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">基础算法记录（二）——部分常见算法问题</h1><div class="post-meta">Mar 26, 2018<span> | </span><span class="category"><a href="/categories/计算机基础/">计算机基础</a><a href="/categories/计算机基础/数据结构与算法/">数据结构与算法</a></span></div><div class="post-content"><h2 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h2><h3 id="假设有一个数组，它的第-i-个元素是一个给定的股票在第-i-天的价格。设计一个算法来找到最大的利润。你可以完成尽可能多的交易（多次买卖股票）。然而，你不能同时参与多个交易（你必须在再次购买前出售股票）。"><a href="#假设有一个数组，它的第-i-个元素是一个给定的股票在第-i-天的价格。设计一个算法来找到最大的利润。你可以完成尽可能多的交易（多次买卖股票）。然而，你不能同时参与多个交易（你必须在再次购买前出售股票）。" class="headerlink" title="假设有一个数组，它的第 i 个元素是一个给定的股票在第 i 天的价格。设计一个算法来找到最大的利润。你可以完成尽可能多的交易（多次买卖股票）。然而，你不能同时参与多个交易（你必须在再次购买前出售股票）。"></a>假设有一个数组，它的第 i 个元素是一个给定的股票在第 i 天的价格。设计一个算法来找到最大的利润。你可以完成尽可能多的交易（多次买卖股票）。然而，你不能同时参与多个交易（你必须在再次购买前出售股票）。</h3><p><em>思路：可以采用贪心法，只要明天的价格高于今天，那么就今天买入，明天卖出，否则今天就不买入。然后继续看后天和明天的情况，以此类推</em></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> [] args)&#123;</span><br><span class="line">Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> count = sc.nextInt();</span><br><span class="line"><span class="keyword">int</span> [] nums = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line"><span class="built_in">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;nums.length;k++)&#123;</span><br><span class="line">nums[k] = sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">sc.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">int</span> rs = s.maxProfit(nums);</span><br><span class="line">System.out.<span class="built_in">println</span>(rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxProfit(<span class="keyword">int</span>[] prices) &#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> =<span class="number">0</span>;</span><br><span class="line"><span class="built_in">while</span>(j&lt;prices.length)&#123;</span><br><span class="line"><span class="built_in">if</span>(prices[i]&lt;prices[j])&#123;</span><br><span class="line"><span class="built_in">max</span> += prices[j]-prices[i];</span><br><span class="line">&#125;</span><br><span class="line">i=j;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> <span class="built_in">max</span>;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机-I"><a href="#买卖股票的最佳时机-I" class="headerlink" title="买卖股票的最佳时机 I"></a>买卖股票的最佳时机 I</h2><h3 id="假设你有一个数组，其中第-i-个元素是一支给定股票第-i-天的价格。如果您只能完成最多一笔交易（即买入和卖出一股股票），则设计一个算法来找到最大的利润。"><a href="#假设你有一个数组，其中第-i-个元素是一支给定股票第-i-天的价格。如果您只能完成最多一笔交易（即买入和卖出一股股票），则设计一个算法来找到最大的利润。" class="headerlink" title="假设你有一个数组，其中第 i 个元素是一支给定股票第 i 天的价格。如果您只能完成最多一笔交易（即买入和卖出一股股票），则设计一个算法来找到最大的利润。"></a>假设你有一个数组，其中第 i 个元素是一支给定股票第 i 天的价格。如果您只能完成最多一笔交易（即买入和卖出一股股票），则设计一个算法来找到最大的利润。</h3><p> <em>思路：股票某天买入和某天卖出所得的利润其实就是每相邻两天之间价格差值之和，那么我们就是要求价格差值之和最大的那部分，即求最大相邻子序列的和，问题转化为求数组中最大连续子序列和</em></p>
<p>假设dp[i]为以i结尾最大连续子序列的和，那么dp[i]=max{dp[i-1]+array[i],array[i]}，最后dp[i]即最大利润。</p>
<p>##买卖股票的最佳时机 III<br><em>如果只能限制两次，那么可以从i=第一天开始到最后一天遍历，左右两边分别动态规划，找出两边和的最大值，和只有一次的进行比较</em></p>
<p>##只出现一次的数字</p>
<p>###给定一个整数数组，除了某个元素外其余元素均出现两次。请找出这个只出现一次的元素。</p>
<p><em>异或相同为0，0异或其他数为该数本身</em></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String [] args</span>)</span>&#123;</span><br><span class="line"> Solution s= <span class="keyword">new</span> Solution();</span><br><span class="line"> Scanner sc= <span class="keyword">new</span> Scanner(System.<span class="keyword">in</span>);</span><br><span class="line"> <span class="keyword">int</span> count = sc.nextInt();</span><br><span class="line"> <span class="keyword">int</span> [] nums = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line"> nums[i] = sc.nextInt();</span><br><span class="line"> &#125;</span><br><span class="line">sc.close();</span><br><span class="line"><span class="keyword">int</span> rs = s.singleNumber(nums);</span><br><span class="line">System.<span class="keyword">out</span>.println(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span> &#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">num ^=nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h2><h3 id="编写一个函数来查找字符串数组中最长的公共前缀字符串"><a href="#编写一个函数来查找字符串数组中最长的公共前缀字符串" class="headerlink" title="编写一个函数来查找字符串数组中最长的公共前缀字符串"></a>编写一个函数来查找字符串数组中最长的公共前缀字符串</h3><p><em>思路：只要以第一个字符串为模板判断是否是第二个的子串，如果不是就将它长度从尾减少一位，继续判断直到找到子串或者匹配不到</em></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> class Solution &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> [] args) &#123;</span><br><span class="line"> Solution test = <span class="keyword">new</span> Solution();</span><br><span class="line"> Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"> <span class="keyword">int</span> count = sc.nextInt();</span><br><span class="line"> sc.nextLine();</span><br><span class="line"> <span class="keyword">String</span>[] strs = <span class="keyword">new</span> <span class="keyword">String</span>[count];</span><br><span class="line"> <span class="built_in">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;count;j++) &#123;</span><br><span class="line">	 strs[j] = sc.nextLine();</span><br><span class="line"> &#125;</span><br><span class="line"> sc.<span class="built_in">close</span>();</span><br><span class="line"> <span class="keyword">String</span> rs = test.longestCommonPrefix(strs);</span><br><span class="line"> System.out.<span class="built_in">println</span>(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> longestCommonPrefix(<span class="keyword">String</span>[] strs) &#123;</span><br><span class="line">     <span class="keyword">String</span> pre = strs[<span class="number">0</span>];</span><br><span class="line">     <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++) &#123;</span><br><span class="line">   	  <span class="built_in">if</span>(pre.length()==<span class="number">0</span>) &#123;</span><br><span class="line">   		  <span class="built_in">break</span>;</span><br><span class="line">   	  &#125;</span><br><span class="line">   	  <span class="built_in">while</span>(strs[i].indexOf(pre)!=<span class="number">0</span>) &#123;</span><br><span class="line">   		  pre = pre.substring(<span class="number">0</span>,pre.length()<span class="number">-1</span>);</span><br><span class="line">   	      <span class="built_in">if</span>(pre.length()==<span class="number">0</span>) <span class="built_in">break</span>;</span><br><span class="line">   	  &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="数数并说"><a href="#数数并说" class="headerlink" title="数数并说"></a>数数并说</h2><h2 id="数数并说序列是一个整数序列，第二项起每一项的值为对前一项的计数，其前五项如下："><a href="#数数并说序列是一个整数序列，第二项起每一项的值为对前一项的计数，其前五项如下：" class="headerlink" title="数数并说序列是一个整数序列，第二项起每一项的值为对前一项的计数，其前五项如下："></a>数数并说序列是一个整数序列，第二项起每一项的值为对前一项的计数，其前五项如下：</h2><ol>
<li>1</li>
<li>11</li>
<li>21</li>
<li>1211</li>
<li>111221</li>
</ol>
<p><em>下一项遍历前一项进行判断就可以了，要注意代码细节问题</em></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String []args</span>)</span> &#123;</span><br><span class="line">	Solution  test = <span class="keyword">new</span> Solution ();</span><br><span class="line">	Scanner sc = <span class="keyword">new</span> Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">	<span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">	sc.close();</span><br><span class="line">	String rs = test.countAndSay(n);</span><br><span class="line">    System.<span class="keyword">out</span>.println(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span>(<span class="params"><span class="keyword">int</span> n</span>)</span> &#123;</span><br><span class="line">   	List&lt;Integer&gt; current = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       List&lt;Integer&gt; last = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       current.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line">       last.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">       	<span class="keyword">return</span> current.toString().replaceAll(<span class="string">"\\pP|\\s*"</span>,<span class="string">""</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">       	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">       		<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">       		<span class="keyword">int</span> count =<span class="number">1</span>;</span><br><span class="line">       		<span class="comment">//此处不能调用clear，因为和last同一块堆内存，会清空前面last保存的内容</span></span><br><span class="line">       		current = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       		<span class="keyword">while</span>(k&lt;last.size()) &#123;</span><br><span class="line">       			<span class="keyword">if</span>(k==last.size()<span class="number">-1</span>) &#123;</span><br><span class="line">       				<span class="keyword">break</span>;</span><br><span class="line">       			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">       				<span class="keyword">if</span>(last.<span class="keyword">get</span>(k).<span class="keyword">equals</span>(last.<span class="keyword">get</span>(k+<span class="number">1</span>))) &#123;</span><br><span class="line">       					count++;</span><br><span class="line">       					k++;</span><br><span class="line">       				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">       					current.<span class="keyword">add</span>(count);</span><br><span class="line">       					current.<span class="keyword">add</span>(last.<span class="keyword">get</span>(k));</span><br><span class="line">       					count =<span class="number">1</span>;</span><br><span class="line">       					k++;</span><br><span class="line">       				&#125;</span><br><span class="line">       			&#125;</span><br><span class="line">       		&#125;</span><br><span class="line">       		current.<span class="keyword">add</span>(count);</span><br><span class="line">       		current.<span class="keyword">add</span>(last.<span class="keyword">get</span>(k));</span><br><span class="line">       		last = current;</span><br><span class="line">       	&#125;</span><br><span class="line">       	</span><br><span class="line">       	<span class="keyword">return</span> current.toString().replaceAll(<span class="string">"\\pP|\\s*"</span>, <span class="string">""</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单的广度优先遍历"><a href="#简单的广度优先遍历" class="headerlink" title="简单的广度优先遍历"></a>简单的广度优先遍历</h2><p><em>广度优先搜素如果是图，则要记录每个节点的访问状态，通过队列实现广度优先，如果每一层的元素都搜素不到满足的解，则入队列准备下一层的搜素，若搜索到，则停止搜素</em></p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class BFS &#123;</span><br><span class="line">int [] node = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">int [] visted= new int[<span class="number">6</span>];</span><br><span class="line">int [][] v = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">public static void main(String [] args) &#123;</span><br><span class="line">	BFS bfs = new BFS();</span><br><span class="line">	Scanner sc = new Scanner(System.in);</span><br><span class="line">	int n = sc.nextInt();</span><br><span class="line">	bfs.visted[n<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">	bfs.searchBFS(n);</span><br><span class="line">&#125;</span><br><span class="line">public void searchBFS(int n) &#123;</span><br><span class="line">	Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">	visted[n<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">	queue.offer(node[n<span class="number">-1</span>]);</span><br><span class="line">	</span><br><span class="line">	while(!queue.isEmpty()) &#123;</span><br><span class="line">		int number = queue.poll();</span><br><span class="line">	    System.out.println(number);</span><br><span class="line">	    for(int i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) &#123;</span><br><span class="line">	    	if(v[i][number<span class="number">-1</span>]==<span class="number">1</span>) &#123;</span><br><span class="line">	    		if(visted[i]!=<span class="number">1</span>) &#123;</span><br><span class="line">	    			queue.offer(node[i]);</span><br><span class="line">	    			visted[i]=<span class="number">1</span>;</span><br><span class="line">	    		&#125;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p><em>深度优先搜素从节点的第一个分支开始搜素，继续递归搜素直到完成或超出深度</em></p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> public class DFS &#123;</span><br><span class="line"> int [] node = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">   int [] visted= new int[<span class="number">6</span>];</span><br><span class="line">   int [][] v = &#123;</span><br><span class="line">  		&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">  		&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">  		&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">  		&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">  		&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">  		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">          &#125;;</span><br><span class="line">  public static void main(String [] args) &#123;</span><br><span class="line">  	DFS dfs = new DFS();</span><br><span class="line">  	Scanner sc = new Scanner(System.in);</span><br><span class="line">  	int n = sc.nextInt();</span><br><span class="line">  	dfs.searchDFS(n);</span><br><span class="line">  &#125;</span><br><span class="line">public void searchDFS(int n) &#123;</span><br><span class="line"> if(visted[n<span class="number">-1</span>]==<span class="number">0</span>) &#123;</span><br><span class="line">  visted[n<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">  System.out.println(node[n<span class="number">-1</span>]);</span><br><span class="line"> &#125;else if(visted[n<span class="number">-1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">  return;</span><br><span class="line"> &#125;</span><br><span class="line"> for(int i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) &#123;</span><br><span class="line">  if(v[i][n<span class="number">-1</span>]==<span class="number">1</span>) &#123;</span><br><span class="line">	  searchDFS(i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="字符串字串的寻找"><a href="#字符串字串的寻找" class="headerlink" title="字符串字串的寻找"></a>字符串字串的寻找</h3><p><em>关于KMP算法，可以参考<a href="http://www.cnblogs.com/yjiyjige/p/3263858.html" title="详解KMP算法" target="_blank" rel="noopener">http://www.cnblogs.com/yjiyjige/p/3263858.html</a></em></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TestKmp &#123;</span><br><span class="line"><span class="keyword">int</span> [] <span class="keyword">next</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String [] args)&#123;</span><br><span class="line">    TestKmp s = <span class="keyword">new</span> TestKmp();</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    String str1 = sc.nextLine();</span><br><span class="line">    String str2 = sc.nextLine();</span><br><span class="line">    sc.close();</span><br><span class="line">    s.getNext(str2.toCharArray());</span><br><span class="line">    <span class="keyword">int</span> rs = s.strStr(str1,str2);</span><br><span class="line">    System.out.<span class="keyword">println</span>(rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kmp</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> strStr(String haystack, String needle) &#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> [] hay = haystack.toCharArray();</span><br><span class="line">    <span class="keyword">char</span> [] need = needle.toCharArray();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;hay.length &amp;&amp; j&lt;need.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==-<span class="number">1</span>||hay[i]==need[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=<span class="keyword">next</span>[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//注意j==length</span></span><br><span class="line">    <span class="keyword">if</span>(j==need.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> i-j;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> getNext(<span class="keyword">char</span> [] child)&#123;</span><br><span class="line">    <span class="keyword">next</span> = <span class="keyword">new</span> <span class="keyword">int</span>[child.length];</span><br><span class="line">    <span class="keyword">next</span>[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">//注意数组溢出问题，每次都是赋值当前索引所在后面的元素</span></span><br><span class="line">    <span class="keyword">while</span>(m&lt;child.length-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==-<span class="number">1</span>||child[k]==child[m])&#123;</span><br><span class="line">            k++;</span><br><span class="line">            m++;</span><br><span class="line">            <span class="keyword">next</span>[m] = k;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            k=<span class="keyword">next</span>[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;<span class="keyword">next</span>.length;l++) System.out.<span class="keyword">println</span>(<span class="string">"next[j]："</span>+<span class="keyword">next</span>[l]);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从数组中找出差值为k的数对的数量，不包括重复组"><a href="#从数组中找出差值为k的数对的数量，不包括重复组" class="headerlink" title="从数组中找出差值为k的数对的数量，不包括重复组"></a>从数组中找出差值为k的数对的数量，不包括重复组</h2><h3 id="比如：-1-5-3-3-1-result-2-1-3-3-5"><a href="#比如：-1-5-3-3-1-result-2-1-3-3-5" class="headerlink" title="比如： 1 5 3 3 1  result=2 {1,3} {3,5}"></a>比如： 1 5 3 3 1  result=2 {1,3} {3,5}</h3><p><em>思路：先将数组排序，再将前面的数和后面比较，相等退出本层循环，继续拿第二个数和后面比较，注意如果第二个数比较前发现与第一个相等，则没有继续比较的必要，跳过本次循环，继续下一个数与后面的比较</em></p>
 <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String []args) &#123;</span><br><span class="line">	Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	<span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">	<span class="keyword">int</span> k = sc.nextInt();</span><br><span class="line">	<span class="keyword">int</span> [] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;n;m++) &#123;</span><br><span class="line">		nums[m] = sc.nextInt();</span><br><span class="line">	&#125;</span><br><span class="line">	sc.close();</span><br><span class="line">	</span><br><span class="line">	Arrays.sort(nums);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;n<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>((nums[j]-nums[i])==k)&#123;</span><br><span class="line">				<span class="keyword">sum</span>++;</span><br><span class="line">				i++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="keyword">sum</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>hopkin</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2018/03/26/基础算法记录（二）——部分常见算法问题/">https://hb-pencil.github.io/2018/03/26/基础算法记录（二）——部分常见算法问题/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>Copyright © 2019 Hopkin</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://hb-pencil.github.io/2018/03/26/基础算法记录（二）——部分常见算法问题/" data-id="ck3bv4yl9004obgibrdjicj76" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADL0lEQVR42u3aQW4jMQwEwPz/015gr7u2u8lJ4FFqToHtSCrOgSCpr6/4efx9Xn/77En+K/nk2Wqvd1k92NjY2DdhJ4dOSDng2Sd50P9dp34B2NjY2MexX2/2OhzJEfMVEt7rUEZJDhsbG/tXsvOgzMqD12kpT5PY2NjY2PnG1zaDZgUMNjY2NnbeVGqPnsCSscEm3Bf00rCxsbE/nv19RcLP//2N821sbGzsj2Q/yicf6+6bRLPfRwpsbGzsg9jtEPeqAqYdKm/SVVGBYWNjY9+QnV98zNv9yaGTb2fvMFoTGxsb+yB2kk42G7cFTBLQTWHzxoWNjY19Q/bm6HnjqW0hta8hD/QFbwwbGxv7I9mzQ8yaO8mYNh88tC8GGxsb+zz2pjWfN25m6eeqsgQbGxv7bPZ+s9kAYDZaSAIaFUXY2NjYx7HbfssmhcwaUrPWVZSxsbGxsW/O3o9g81ZOOzzIG1J5Ei3qMGxsbOzbsmeN+Pyg7dWf2ZrF77GxsbFvzs4Hru0R8/XzJDQbHke5GhsbG/u27Lw1kw9lZwfdf9tasLGxsU9i5yPVfRto1rTajx+KGggbGxv7CHY+Xm3xm/ImLzYuyNjY2NjYt2W3bfe8YbRfYf9gY2Njn8qebdyWNLMktxkbFPNtbGxs7Nuy8yMmiW1zbyih5iu/CRM2Njb2cez86sws4c1GEbMhQbQLNjY29nHs2ZWX5OLOLMRtoypvJ0V5GxsbG/u27Pbvqy7WbNLY8FIRNjY29kHsvKWeD4A3DaCrLgzVg15sbGzsm7Nng9V8hJC0lmbBKhpJF0wVsLGxsT+R3Q4DrhoA55d7ZqXLm9NiY2NjH8rOWz+bRJW0geoqqkxy2NjY2Cex89b8rJzYfJKDN00ubGxs7LuzH+XTDhXavfImVz7i/c/5sbGxsQ9it8mgBeyTVrtaWw5hY2Njn8HOk0pyoScP0Gb3PIE9TavY2NjYx7GTpJUPd9tLNm0Smp0BGxsbGztvAG0aPftiIwoTNjY2Nnbwy3yXvPBohwTY2NjYv4e9STx5ONqyIQ9B+1/Y2NjYJ7HbQW+e6vYrtOtsFNjY2Ng3ZP8BxA6bp5oPuKUAAAAASUVORK5CYII=">分享</a><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/03/27/基础算法（一）——八大排序算法实现Kotlin/">基础算法（一）——八大排序算法实现Kotlin</a><a class="next" href="/2018/03/16/Android暑期实习面经部分笔试记录（一）/">Android暑期实习面经部分笔试记录（一）</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/Android知识/">Android知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/计算机网络/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/计算机语言/">计算机语言</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/经验记录/" style="font-size: 15px;">经验记录</a> <a href="/tags/随笔杂文/" style="font-size: 15px;">随笔杂文</a> <a href="/tags/小技巧/" style="font-size: 15px;">小技巧</a> <a href="/tags/计算机知识/" style="font-size: 15px;">计算机知识</a> <a href="/tags/他山之石/" style="font-size: 15px;">他山之石</a> <a href="/tags/新技术/" style="font-size: 15px;">新技术</a> <a href="/tags/胡思乱想/" style="font-size: 15px;">胡思乱想</a> <a href="/tags/经验总结/" style="font-size: 15px;">经验总结</a> <a href="/tags/kotlin/" style="font-size: 15px;">kotlin</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/Activity的启动过程浅析/">Activity的启动过程浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/kotlin的若干特性/">Kotln的若干特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/20/经验总结（四）/">经验总结（四）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/08/经验总结（三）/">经验总结（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/25/事件总线思想简述/">事件总线思想简述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/24/经验总结（二）/">经验总结（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/11/经验总结（一）/">经验总结（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/12/工作业余计划/">工作业余计划</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/08/Android自定义FlowLayout/">Android自定义FlowLayout</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/22/打家劫舍123/">打家劫舍123</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Hopkin.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>